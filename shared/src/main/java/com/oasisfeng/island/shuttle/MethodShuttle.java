package com.oasisfeng.island.shuttle;

import android.annotation.SuppressLint;
import android.content.Context;
import android.os.DeadObjectException;
import android.os.Parcel;
import android.os.RemoteException;
import android.util.Log;

import androidx.annotation.Nullable;

import com.oasisfeng.android.service.AidlService;
import com.oasisfeng.android.service.Services;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

/**
 * Shuttle for general method invocation, on top of service shuttle.
 *
 * Created by Oasis on 2017/3/31.
 */
public class MethodShuttle {

	public interface GeneralVoidMethod extends ShuttleMethod { void invoke(); }
	public interface GeneralMethod<ReturnType> extends ShuttleMethod { ReturnType invoke(); }
	public interface GeneralContextFunction<ReturnType> extends ShuttleMethod { ReturnType apply(Context context) throws RemoteException; }
	public interface GeneralContextRunnable extends ShuttleMethod { void run(Context context) throws RemoteException; }

	private interface ShuttleMethod {}

	/** @param lambda should be a lambda function without return value.
	 *                Context (but not its derivation) and types acceptable by {@link Parcel#writeValue(Object)} can be carried. */
	public static CompletionStage<Void> runInProfile(final Context context, final GeneralVoidMethod lambda) {
		return shuttle(context, lambda);
	}

	/** @param lambda should be a lambda function with return value of type <code>R</code>.
	 *                Context (but not its derivation) and types acceptable by {@link Parcel#writeValue(Object)} can be carried. */
	public static <R> CompletionStage<R> runInProfile(final Context context, final GeneralMethod<R> lambda) {
		return shuttle(context, lambda);
	}

	public static <R> CompletionStage<R> runInProfile(final Context context, final GeneralContextFunction<R> lambda) {
		return shuttle(context, lambda);
	}

	public static CompletionStage<Void> runInProfile(final Context context, final GeneralContextRunnable lambda) {
		return shuttle(context, lambda);
	}

	private static <Result> CompletionStage<Result> shuttle(final Context context, final ShuttleMethod lambda) {
		final Class<?> clazz = lambda.getClass();
		final Constructor<?>[] constructors = clazz.getDeclaredConstructors();
		if (constructors.length < 1) throw new IllegalArgumentException("The method must have at least one constructor");
		final Constructor<?> constructor = constructors[0];		// Extra constructor may be generated by "Instant Run" of Android Studio.
		final Class<?>[] constructor_params = constructor.getParameterTypes();

		final Field[] fields = clazz.getDeclaredFields();
		final Object[] args;
		if (constructor_params.length > 0) {
			if (fields.length < constructor_params.length)		// Extra fields may be added by dev tools (e.g. instant-run).
				throw new IllegalArgumentException("Parameter types mismatch: " + constructor + " / " + Arrays.deepToString(fields));

			args = new Object[constructor_params.length];
			for (int i = 0; i < constructor_params.length; i++) try {
				final Field field = fields[i];
				if (field.getType() != constructor_params[i])
					throw new IllegalArgumentException("Parameter types mismatch: " + constructor + " / " + Arrays.deepToString(fields));
				field.setAccessible(true);
				final Object arg = field.get(lambda);
				if (field.getType() != Context.class) args[i] = arg;		// Context argument is intentionally left blank.
			} catch (final Exception e) {
				throw new IllegalArgumentException("Error enumerating lambda parameters.", e);
			}
		} else args = new Object[0];

		final MethodInvocation<Result> invocation = new MethodInvocation<>();
		invocation.clazz = clazz.getName();
		invocation.args = args;
		final CompletableFuture<Result> future = new CompletableFuture<>();
		final Services.ServiceReadyThrows<IMethodShuttle, DeadObjectException> procedure = shuttle -> {
			sCachedShuttle = shuttle;
			try {
				shuttle.invoke(invocation);
			} catch (final DeadObjectException e) {
				throw e;		// Required by sCachedShuttle to identify dead binder (isBinderAlive() is not reliable)
			} catch (final Exception e) {
				Log.w(TAG, "Error executing " + invocation.clazz, e);
				future.completeExceptionally(e);
				return;
			}
			if (invocation.throwable != null) future.completeExceptionally(invocation.throwable);
			else future.complete(invocation.result);
		};

		if (sCachedShuttle != null && sCachedShuttle.asBinder().isBinderAlive()) try {
			procedure.onServiceReady(sCachedShuttle);
			return future;
		} catch (final DeadObjectException ignored) {}    // Fall-through to reconnect

		if (Services.use(new ServiceShuttleContext(context), IMethodShuttle.class, IMethodShuttle.Stub::asInterface, procedure)) return future;
		final CompletableFuture<Result> failure = new CompletableFuture<>();
		failure.completeExceptionally(new IllegalStateException("Error connecting " + MethodShuttleService.class.getCanonicalName()));
		return failure;
	}

	private MethodShuttle() {}

	private static volatile IMethodShuttle sCachedShuttle;

	@SuppressLint("Registered")		// Actually declared in the AndroidManifest.xml of module "engine".
	public static class MethodShuttleService extends AidlService<IMethodShuttle.Stub> {

		@Nullable @Override protected IMethodShuttle.Stub createBinder() {
			return new IMethodShuttle.Stub() { @Override public void invoke(final MethodInvocation invocation) {
				try {
					final Class<?> clazz = Class.forName(invocation.clazz);
					final Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
					constructor.setAccessible(true);
					final Object[] args = invocation.args;
					final Class<?>[] arg_types = constructor.getParameterTypes();
					for (int i = 0; i < arg_types.length; i ++) if (arg_types[i] == Context.class) args[i] = MethodShuttleService.this;	// Fill in context
					final Object instance = constructor.newInstance(args);
					if (instance instanceof GeneralContextRunnable)
						((GeneralContextRunnable) instance).run(MethodShuttleService.this);
					else if (instance instanceof GeneralContextFunction)
						invocation.result = ((GeneralContextFunction) instance).apply(MethodShuttleService.this);
					else if (instance instanceof GeneralVoidMethod)
						((GeneralVoidMethod) instance).invoke();
					else if (instance instanceof GeneralMethod)
						invocation.result = ((GeneralMethod) instance).invoke();
					else throw new IllegalArgumentException("Internal error: method mismatch");
				} catch (Throwable t) {
					if (t instanceof InvocationTargetException) t = ((InvocationTargetException) t).getTargetException();
					invocation.throwable = t;
					Log.w(TAG, "Error executing " + invocation.clazz, t);
				}
			}};
		}
	}

	private static final String TAG = "Shuttle";
}
