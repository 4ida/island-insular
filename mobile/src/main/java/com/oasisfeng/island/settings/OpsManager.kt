package com.oasisfeng.island.settings

import android.app.Activity
import android.app.AppOpsManager
import android.content.pm.ApplicationInfo
import android.content.pm.ApplicationInfo.FLAG_SYSTEM
import android.content.pm.ApplicationInfo.FLAG_UPDATED_SYSTEM_APP
import android.content.pm.PackageManager.GET_PERMISSIONS
import android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES
import android.os.Build.VERSION_CODES.P
import android.os.Process
import android.widget.Toast
import androidx.annotation.RequiresApi
import com.oasisfeng.android.os.UserHandles
import com.oasisfeng.android.ui.Dialogs
import com.oasisfeng.android.util.Apps
import com.oasisfeng.island.appops.AppOpsHelper
import com.oasisfeng.island.data.helper.hidden
import com.oasisfeng.island.mobile.R
import com.oasisfeng.island.util.Hacks
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@RequiresApi(P) class OpsManager(private val activity: Activity, private val permission: String, private val op: Int) {

	internal fun startOpsManager(prompt: Int) = GlobalScope.launch(Dispatchers.Main) {
		val progress = Dialogs.buildProgress(activity, R.string.prompt_appops_loading).indeterminate().onCancel { mCanceled = true }.start()
		val apps = buildSortedAppList()
		if (mCanceled) return@launch
		progress.dismiss()
		if (apps == null) return@launch
		if (apps.isNotEmpty()) show(apps, prompt)
		else Dialogs.buildAlert(activity, 0, R.string.prompt_appops_no_such_apps).setPositiveButton(R.string.action_done, null).show()
	}

	private fun show(apps: List<AppInfoWithOps>, prompt: Int) {
		val checkedItems = BooleanArray(apps.size) { i -> ! apps[i].mRevoked }
		Dialogs.buildCheckList(activity, activity.getString(prompt), apps.map { it.mLabel }.toTypedArray(), checkedItems) { _, which, checked ->
			apps[which].also { if (checked) it.resetToDefault() else it.revoke() }
		}.setNeutralButton(R.string.action_revoke_all) { _, _ ->
			Dialogs.buildAlert(activity, R.string.dialog_title_warning, R.string.prompt_appops_revoke_for_all_users_apps)
					.withOkButton { apps.forEach { if (! it.mSystem) it.revoke() } }
					.withCancelButton().show()
		}.setPositiveButton(R.string.action_done, null).show()
	}

	/** Revoked first, granted & denied first (unused last), system apps last (user apps first), then by label */
	private suspend fun buildSortedAppList(): List<AppInfoWithOps>? = withContext(Dispatchers.IO) {   // null if canceled
		val entries = HashMap<String, AppInfoWithOps>()
		// Apps with permission granted
		activity.packageManager.getPackagesHoldingPermissions(arrayOf(permission), 0).forEach {
			if (isUserAppOrUpdatedNonPrivilegeSystemApp(it.applicationInfo))
				entries[it.packageName] = AppInfoWithOps(it.applicationInfo, it.packageName !in mOpsRevokedPkgs) }
		if (mCanceled) return@withContext null
		// Frozen apps and apps with explicit app-op revoked
		val apps = activity.packageManager.getInstalledPackages(GET_PERMISSIONS or MATCH_UNINSTALLED_PACKAGES)
		if (mCanceled) return@withContext null
		apps.forEach {
			val pkg = it.packageName; val app = it.applicationInfo
			if (pkg !in entries && Apps.isInstalledInCurrentUser(app) && isUserAppOrUpdatedNonPrivilegeSystemApp(app)
					&& (pkg in mOpsRevokedPkgs || it.requestedPermissions?.contains(permission) == true)) {
				if (mCanceled) return@withContext null
				entries[pkg] = AppInfoWithOps(app, false) }}
		return@withContext entries.values.sortedWith(compareBy({ ! it.mRevoked }, { ! it.mGranted }, { it.mSystem }, { it.mLabel }))
	}

	private fun isUserAppOrUpdatedNonPrivilegeSystemApp(app: ApplicationInfo)   // Limited to "updated" to filter out unwanted system apps but still keep possible bloatware
			= (app.flags and FLAG_SYSTEM == 0 || (app.flags and FLAG_UPDATED_SYSTEM_APP != 0 && ! Apps.isPrivileged(app)))
			&& UserHandles.getAppId(app.uid) != mAppId

	private inner class AppInfoWithOps(private val info: ApplicationInfo, val mGranted: Boolean) {

		fun revoke() = mAppOps.setMode(pkg, op, AppOpsManager.MODE_IGNORED, info.uid).showToastIfFalse()
		fun resetToDefault() = mAppOps.resetToDefault(pkg, op, info.uid).showToastIfFalse()

		private fun Boolean.showToastIfFalse() {
			if (! this) Toast.makeText(activity, R.string.prompt_operation_failure_due_to_incompatibility, Toast.LENGTH_LONG).show()
		}

		val mLabel by lazy {
			StringBuilder().apply {
				if (mSystem) append(mSystemPrefix).append(' ')
				append(mAppsHelper.getAppName(info))
				if (mGranted) append(' ').append(mGrantedSuffix)
				if (info.hidden) append(' ').append(mHiddenSuffix)
			}.toString()
		}

		val pkg: String = info.packageName
		val mRevoked = mOpsRevokedPkgs.contains(pkg)

		internal val mSystem = Apps.isSystem(info)
	}

	private val mAppsHelper = Apps.of(activity)
	private val mAppOps = AppOpsHelper(activity)
	private val mOpsRevokedPkgs by lazy { mAppOps.getPackageOps(op).mapNotNull { entry -> entry.key.takeIf { isOpRevoked(entry.value) }}}
	private val mAppId = UserHandles.getAppId(Process.myUid())
	private var mCanceled = false

	private val mSystemPrefix = activity.getString(R.string.label_prefix_for_system_app)
	private val mGrantedSuffix = activity.getString(R.string.label_suffix_permission_granted)
	private val mHiddenSuffix = activity.getString(R.string.default_launch_shortcut_prefix).trimEnd()

	companion object {

		fun isOpRevoked(pkgOps: Hacks.AppOpsManager.PackageOps)
				= pkgOps.ops?.getOrNull(0)?.mode ?: AppOpsManager.MODE_ALLOWED != AppOpsManager.MODE_ALLOWED
	}
}
